Análisis del Módulo: Sistema de Gestión de Mesas
1. Propósito del Módulo
Este módulo implementa un sistema de gestión de mesas para restaurantes enfocado en el control visual y operativo de las mesas del establecimiento. Su función principal es permitir el seguimiento en tiempo real del estado de las mesas, visualización de consumos pendientes y procesamiento de cobros de manera eficiente.
2. Funcionalidades Principales
Gestión Visual de Mesas:

Grid interactivo: Visualización de todas las mesas en formato cuadrícula
Estados visuales: Diferenciación clara entre mesas libres y ocupadas
Indicadores de estado: Colores y textos descriptivos para cada estado
Información inmediata: Total pendiente por mesa visible al instante

Sistema de Cobros:

Modal de detalles: Vista completa de consumos por mesa
Desglose de productos: Lista detallada de items consumidos con cantidades y precios
Cálculo automático: Total acumulado con formato de moneda local
Procesamiento de cobro: Funcionalidad completa para cerrar cuentas

Dashboard de Control:

KPIs en tiempo real: Mesas activas y total pendiente
Actualización automática: Refresh cada 30 segundos
Resumen del día: Estadísticas consolidadas de la operación

Experiencia de Usuario:

Interfaz intuitiva: Click directo en mesas ocupadas para ver detalles
Feedback visual: Estados de carga y confirmaciones
Formato local: Moneda colombiana (COP) con formateo apropiado

3. Dependencias Identificadas
Dependencias Externas:

React: Hooks básicos (useState, useEffect)
Lucide React: Iconografía (X, DollarSign, Clock, RefreshCw)
@spoon/shared: Biblioteca compartida del sistema

Dependencias Internas Críticas:

UI Components: Button de la biblioteca compartida
Context: useSetPageTitle para manejo de títulos de página
Services: getMesasEstado, cobrarMesa, getUserRestaurant, getDetallesMesa
Types: Mesa, ItemMesa, EstadoMesas del sistema de tipos compartido
Constants: COLORES_ESTADO, TEXTOS_ESTADO, TOTAL_MESAS_DEFAULT

Estructura de Datos Esperada:
typescript// Base de datos debe tener:
- Tabla de órdenes activas por mesa
- Relación con restaurant_id
- Items de orden con precios y cantidades
- Estado de mesas (ocupada/libre)
4. Errores e Inconsistencias Detectadas
Errores Críticos:

Dependencia de debug en producción (MesaModal.tsx, línea 90):

typescript{process.env.NODE_ENV === 'development' && // Debug info en producción
Riesgo: Información sensible podría filtrarse

Falta de validación de datos (MesaModal.tsx):

typescript// No valida si detalles.items existe antes de mapear
{detalles.items.map((item, index) => ( // Puede fallar

Manejo de errores insuficiente (useMesas.ts):

typescript} catch (error) {
  console.error('Error cargando mesas:', error);
  // No hay feedback al usuario sobre el error
}
Problemas de Arquitectura:

Lógica de formateo duplicada: formatCurrency se repite en múltiples componentes
Estado local no sincronizado: Auto-refresh puede generar inconsistencias
Falta de optimistic updates: Las acciones no muestran feedback inmediato

Issues de UX/UI:

No hay confirmación de cobro: Acción crítica sin confirmación
Loading states inconsistentes: Algunos componentes no muestran estados de carga
Falta de manejo de errores de red: Conexión perdida no se comunica al usuario

5. Sugerencias de Mejora
Correcciones Inmediatas:
typescript// 1. Validación robusta de datos
const renderItems = () => {
  if (!detalles?.items?.length) {
    return <div>No hay items registrados</div>;
  }
  
  return detalles.items.map((item, index) => {
    if (!item || typeof item.precio_total !== 'number') {
      console.warn('Item inválido:', item);
      return null;
    }
    // Render seguro...
  });
};

// 2. Utility centralizado para formato
// utils/currency.ts
export const formatCurrency = (amount: number): string => {
  if (typeof amount !== 'number' || isNaN(amount)) {
    console.warn('Formato de moneda inválido:', amount);
    return '$0';
  }
  
  return new Intl.NumberFormat('es-CO', {
    style: 'currency',
    currency: 'COP',
    minimumFractionDigits: 0
  }).format(amount);
};

// 3. Confirmación de cobro
const handleCobrar = async () => {
  const confirmado = await showConfirmDialog(
    '¿Confirmar cobro?',
    `Total: ${formatCurrency(detalles.total)}`
  );
  
  if (!confirmado) return;
  
  // Procesar cobro...
};
Mejoras Arquitectónicas:

Context para estado global:

typescript// MesasContext.tsx
interface MesasContextType {
  mesasEstado: EstadoMesas;
  loading: boolean;
  error: string | null;
  actualizarMesa: (numero: number) => Promise<void>;
  procesarCobro: (numero: number) => Promise<boolean>;
}

Hook optimizado con cache:

typescript// useMesas.ts mejorado
export const useMesas = () => {
  const [cache, setCache] = useState<Map<string, EstadoMesas>>(new Map());
  
  const cargarMesas = useCallback(async () => {
    const cacheKey = `mesas_${restaurantId}_${Date.now()}`;
    // Implementar cache inteligente
  }, [restaurantId]);
};

Error boundaries específicos:

typescript// MesasErrorBoundary.tsx
export const MesasErrorBoundary: React.FC<{children: React.ReactNode}> = ({children}) => {
  return (
    <ErrorBoundary
      fallback={<MesasErrorFallback />}
      onError={(error) => logMesasError(error)}
    >
      {children}
    </ErrorBoundary>
  );
};
Optimizaciones de Rendimiento:

Memoización de componentes:

typescriptconst MesaCard = React.memo<MesaCardProps>(({numero, estado, total, onClick}) => {
  // Implementación memoizada
});

Virtualización para muchas mesas:

typescript// Para restaurantes con 50+ mesas
import { FixedSizeGrid as Grid } from 'react-window';

Debounce en actualizaciones:

typescriptconst debouncedRefresh = useMemo(
  () => debounce(cargarMesas, 1000),
  [cargarMesas]
);
6. Observaciones para IAs Futuras
Contexto del Sistema:

Este módulo maneja operaciones financieras críticas (cobros de mesas)
Debe ser 100% confiable durante horarios de servicio
Es usado por personal de servicio con diferentes niveles técnicos
Requiere sincronización en tiempo real entre múltiples dispositivos

Patrones de Diseño Implementados:

Presentation/Container Pattern en MesasPage/MesaCard
Modal Pattern para detalles de mesa
Auto-refresh Pattern con intervalo fijo
State Management local con React hooks

Flujo de Datos Crítico:
Usuario → Click Mesa → Cargar Detalles → Mostrar Modal → 
Confirmar Cobro → Procesar Pago → Actualizar Estado → 
Sincronizar con Base de Datos → Actualizar UI
Consideraciones de Testing:

Mock de servicios de mesa es esencial
Estados de error requieren cobertura completa
Operaciones de cobro necesitan testing exhaustivo
Auto-refresh debe testearse con timers

Datos de Entrada Esperados:
typescript// El sistema requiere:
1. Restaurant activo con mesas configuradas
2. Órdenes activas vinculadas a mesas
3. Items de orden con precios válidos
4. Conexión estable para actualizaciones

// Estructura típica de mesa ocupada:
{
  numero: 5,
  total: 45000,
  items: [
    {
      id: 'item_1',
      nombre: 'Menú Ejecutivo',
      cantidad: 2,
      precio_total: 30000
    }
  ]
}
Limitaciones Actuales:

No hay sistema de reservas integrado
Falta división de cuentas para grupos
No hay asignación de meseros por mesa
Ausencia de tiempo de ocupación tracking
Sin notificaciones para mesas que esperan cobro
No hay reportes de rotación de mesas

Puntos de Extensión:

Sistema de reservas con calendario
Asignación de meseros por mesa
División de cuentas para grupos
Alertas de tiempo de ocupación
Dashboard analítico de rotación
Integración con POS para órdenes automáticas
App móvil para meseros
Sistema de propinas digitales

Consideraciones de Seguridad:

Validar permisos antes de cobrar
Log de todas las transacciones para auditoría
Prevenir cobros dobles con locks
Backup de datos antes de operaciones críticas

Este módulo es fundamental para las operaciones diarias del restaurante y requiere máxima estabilidad y precisión en el manejo de transacciones financieras.


============================================================
Mapa técnico detallado (por archivo)
============================================================

1) apps/web/src/app/dashboard/mesas/pages/MesasPage.tsx
- Rol: Orquestador de UI para el administrador de Mesas. Renderiza grid, panel lateral de detalles, wizard de creación de orden, configuración inicial y flujo de cobro.
- Entradas/Dependencias:
  - useMesas (orquestador de dominio) y/o useMesasMaestro (modelo unificado)
  - useCajaSesion: Gate de “caja abierta” para habilitar acciones (crear/cobrar)
  - Componentes: MesaCard, MesaDetailsPanel, CrearOrdenWizard, ConfiguracionMesasPanel
  - Utils: formateadores de moneda y helpers de estado
- Estados/eventos claves:
  - Apertura del wizard para crear orden; cierre y recarga tras guardar
  - Apertura del panel de detalles; acciones delegadas (editar/eliminar/reservar/etc.)
  - Flujo de cobro: confirma, arma datos de recibo, invoca procesarCobro y refresca; muestra overlay de recibo
- Contratos:
  - Espera que useMesas exponga: cargarMesas, procesarCobro, configurarMesasIniciales, acciones por mesa, y colección normalizada de mesas
  - Si no hay caja abierta, bloquea acciones críticas y muestra aviso contextual

2) apps/web/src/app/dashboard/mesas/pages/MesaCard.tsx
- Rol: Tarjeta visual de mesa dentro del grid.
- Props principales: numero, estado ('vacia'|'ocupada'), total, onClick, seleccionada; compatibilidad extendida con sistema maestro (nombre, zona, capacidad, estadoMesa, items, comensales, inicioAtencion, mesero).
- Lógica:
  - Determina presentación a partir de getEstadoDisplay y COLORES_ESTADO/TEXTOS_ESTADO.
  - Calcula tiempo transcurrido si inicioAtencion está presente (intervalo local cada 60s).
  - Usa un formateo de moneda inline (Intl.NumberFormat). Recomendado: reemplazar por util compartido formatearMoneda.
- UI:
  - Colores/gradientes por estado (libre/ocupada/reservada/inactiva/mantenimiento/en_cocina/servida/por_cobrar).
  - Badges para estados especiales; indicadores; accesibilidad con aria-label.

3) apps/web/src/app/dashboard/mesas/components/MesaDetailsPanel.tsx
- Rol: Contenedor que compone Header + Content + Actions + Footer para el detalle de una mesa.
- Flujo:
  - Renderiza según estado de mesa y existencia de ordenActiva.
  - Delegación a useMesaActions para crear/eliminar orden, reservar/liberar, activar/inactivar, mantenimiento y cobrar.
  - Hoy usa prompts/alerts nativos para confirmaciones. Recomendado: reemplazar por dialog/confirm centralizado.
- Contratos:
  - Recibe la mesa seleccionada, estados de carga de acciones y callbacks de acciones (inyectados desde MesasPage/useMesas).

4) apps/web/src/app/dashboard/mesas/components/MesaDetailsHeader.tsx
- Rol: Encabezado del panel de detalles; muestra nombre/numero, estado y capacidad.
- Dependencias: getEstadoDisplay, formatearNombreMesa, formatearCapacidad; íconos (X, Users).
- Contrato: Props { mesa, onClose }.

5) apps/web/src/app/dashboard/mesas/components/MesaDetailsContent.tsx
- Rol: Cuerpo del panel; muestra items de la orden, totales, y vistas específicas por estado (libre/ocupada/reservada/inactiva/mantenimiento).
- Dependencias: formatearMoneda, calcularTiempoOcupacion, formatearTiempoOcupacion.
- Lógica: Cuando ocupada, lista items con cantidad, unitario y total; estadísticas de items/productos; múltiples cajas informativas por estado.
- Contrato: Props { mesa, loading? }.

6) apps/web/src/app/dashboard/mesas/components/MesaDetailsActions.tsx
- Rol: Conjunto de botones/acciones según estado.
- Dependencias: Button compartido; getAccionesDisponibles (de utils/mesas); íconos Lucide.
- Comportamiento:
  - libre: Crear orden, Reservar, Mantenimiento, Inactivar
  - ocupada: Editar/Eliminar orden
  - reservada: Crear orden (libera)/Liberar reserva
  - inactiva/mantenimiento: Activar/Actualizar notas
- Contrato: Props con callbacks específicos (onCrearOrden, onEditarOrden, onEliminarOrden, onReservarMesa, onLiberarReserva, onActivarMesa, onInactivarMesa, onPonerMantenimiento, onActualizarNotas).

7) apps/web/src/app/dashboard/mesas/components/MesaDetailsFooter.tsx
- Rol: Footer con botón principal de cobro y cierre del panel.
- Dependencias: Button, DollarSign, formatearMoneda.
- Lógica: Si mesa está ocupada y hay ordenActiva, habilita COBRAR; muestra spinner mientras cobra.
- Contrato: Props { mesa, cobrando?, onCobrar, onClose }.

8) apps/web/src/app/dashboard/mesas/components/EditarMesaModal.tsx
- Rol: Modal para editar configuración visual/operativa de una mesa (nombre, zona, capacidad, notas).
- Lógica:
  - Valida capacidad [1..20] y longitud mínima de zona.
  - Emite onGuardar(datosActualizados) y cierra si hay éxito.
  - Atajos: ESC para cerrar; bloqueo del scroll en apertura.
- Nota de modelo: Hay comentarios de que “zona” fue eliminada del esquema en DB; la UI aún la expone. Definir política: o persistir en un metadato separado o remover del modelo UI si no aplica.

9) packages/shared/hooks/mesas/useMesas.ts (orquestador actual)
- Rol: Orquestar estado de mesas y acciones. Tiene bandera para “sistema maestro” vs ruta legacy.
- Maestro: Normaliza items y totales; expone cargarMesas, procesarCobro (transaccional), configurarMesasIniciales; compone acciones desde useMesaActions.
- Legacy: Usa useMesaState + useMesaActions + useMesaConfig + useMesaStats; entrega colección “mesasCompletas” y acciones derivadas.
- Contratos clave: procesarCobro espera datos de recibo; refresca estado tras éxito.

10) packages/shared/hooks/mesas/core/useMesaState.ts
- Rol: Fuente única de estado local (mesas, configuración, estadísticas) y sincronización con API/DB.
- Dependencias Supabase (cargas):
  - getEstadoCompletoMesas(restaurantId): Trae mesas + detalles de orden (items, totales)
  - verificarMesasConfiguradas(restaurantId): Determina si hay setup inicial (totalMesas, zonas)
- Lógica de normalización:
  - Construye ordenActiva a partir de “detallesOrden” resolviendo precioUnitario/Total con varios fallbacks (generated_combinations o precio_total/cantidad).
  - Si hay ordenActiva con items y estado venía 'libre' → fuerza visual 'ocupada' (resolves inconsistencias de origen).
- Auto-refresh: Intervalo 30s condicionado a restaurantId y configuradas=true.
- Expone: sincronizarMesas, sincronizarConfiguracion, limpiarError; flags de loading y error.

11) packages/shared/hooks/mesas/core/useMesasMaestro.ts
- Rol: API de “modelo unificado” para la UI. Mapea estado extendido de UI a par (estado_mesa, estado_orden) y devuelve “MesaCompletaMaestro”.
- splitEstados: Traduce 'en_cocina'|'servida'|'por_cobrar' a estado_mesa='ocupada' con estado_orden derivado; valida 'libre'|'ocupada'|'reservada'|'inactiva'.
- Acciones: Proxies a useMesaActions (crear/eliminar orden, reservar/inactivar/activar) y a useMesaConfig (configurarMesas). TODO explícito para estados finos de orden.

12) packages/shared/hooks/mesas/core/useMesaConfig.ts
- Rol: Configurar, reconfigurar, limpiar configuración y crear mesa individual.
- Validaciones: validarConfiguracionMesa; límites de totalMesas; capacidad [según constants].
- Supabase: configurarMesas, reconfigurarMesas, limpiarConfiguracionMesas, crearMesa.
- Callback onSuccess: re-sincroniza configuración + mesas.

13) packages/shared/hooks/mesas/core/useMesaActions.ts
- Rol: Encapsula acciones transaccionales y de ciclo de vida:
  - crearOrden (con validación), cobrarMesa/procesarCobro (transaccional), reservarMesa/liberarReserva, activar/inactivar, ponerMantenimiento, eliminarOrden.
- Manejo de estados de carga por acción; validadores (crear orden, reserva) desde utils.
- Dependencias: métodos compartidos de Supabase (transacciones y mutaciones por mesa/orden).

14) packages/shared/hooks/mesas/core/useMesaStats.ts
- Rol: Cálculo de estadísticas derivadas y versiones formateadas para UI.
- Cálculos: totales por estado, totalPendiente/promedioTicket, porcentajes de ocupación/disponibilidad; breakdown por zona; “mesas más ocupadas” por tiempo; “zonas más activas”.
- API futura: obtenerEstadisticasPorPeriodo y obtenerTendenciasOcupacion (stubs preparados).

15) packages/shared/types/mesas/mesasTypes.ts
- Rol: Archivo de compatibilidad que re-exporta tipos de ./stateTypes y ./actionTypes.
- Nota: marcar como @deprecated y preferir imports específicos para reducir acoplamiento.

16) packages/shared/utils/mesas/mesaFormatters.ts
- formatearMoneda: Usa FORMATO_MONEDA desde constants y Intl.
- formatearTiempoOcupacion: Convierte minutos a “Xm”/“Xh Ym”.
- formatearNombreMesa, formatearCapacidad, formatearResumenOrden, formatearNotaConFecha, formatearPorcentaje.

17) packages/shared/utils/mesas/mesaValidators.ts
- validarConfiguracionMesa(numero, nombre, zona?, capacidad)
- validarCrearOrden(CrearOrdenData)
- validarReserva(nombreCliente, telefono?, horaReserva?)
- Usa CONFIG_MESAS (límites, rangos), y valida tipos/valores.

18) Constants y Helpers relevantes
- @spoon/shared/constants/mesas/mesasConstants: TEXTOS_ESTADO, COLORES_ESTADO, FORMATO_MONEDA, CONFIG_MESAS...
- @spoon/shared/utils/mesas: getEstadoDisplay, getAccionesDisponibles, calcularTiempoOcupacion, etc.


Gaps y recomendaciones (acciones prácticas)
------------------------------------------
1) Confirmaciones y feedback unificados
- Reemplazar alert/prompt nativos por un ConfirmDialog/Toast compartido (consistencia y accesibilidad).
- Cobro: siempre confirmar con total (formatearMoneda) y mostrar resultado con recibo/ID de transacción.

2) Formateo de moneda centralizado
- Sustituir Intl.NumberFormat inline en MesaCard por formatearMoneda del shared utils.

3) Zona en el modelo
- La columna “zona” fue eliminada del esquema según comentarios en hooks; varias UIs aún la usan. Decidir:
  - a) Mantener como metadato UI (persistir en tabla auxiliar o JSONB de mesa), o
  - b) Retirarla de la UI y usar solo “Principal” por defecto. Documentar decisión para evitar drift.

4) Adoptar modelo maestro por defecto
- Migrar llamadas de useMesas a useMesasMaestro donde sea posible para un contrato estable: estado_mesa vs estado_orden, y normalización consistente.

5) Realtime y actualizaciones optimistas
- Suscribirse a cambios de órdenes/mesas vía Supabase Realtime para reducir el polling a 30s o eliminarlo.
- Optimistic UI para crear/eliminar items y reservas; fallback con revalidación.

6) Validaciones y guardas de caja
- En UI ya hay gate de “caja abierta”; reforzar en backend/RPCs que crear/cobrar/eliminar orden requieran sesión de caja activa para el restaurant.

7) Testing mínimo recomendado
- useMesaState: normalización de items y coerción de estado 'libre'→'ocupada' con orden.
- useMesaActions: rutas de éxito y error (incluye validarCrearOrden y validarReserva).
- MesaCard: snapshot de estados (libre/ocupada/reservada/inactiva/mantenimiento) y a11y (aria-label).
- MesaDetailsContent: render de items y totales; casos vacíos.

8) Errores y toasts
- Donde hoy solo se hace console.error, emitir toast de error con acción de reintento (ej. recargar mesas).

9) Editar mesa: persistencia real
- El modal EditarMesaModal emite onGuardar; asegurar que exista endpoint para update parcial de mesa (nombre/capacidad/notas[/zona si aplica]) y refresco posterior.

10) Performance
- Considerar memo de MesaCard y virtualización del grid cuando #mesas >50; mantener sombras/transiciones bajo control para hardware modesto.

Cobertura de requisitos (resumen)
- Gate de caja para acciones críticas: OK en UI; pendiente refuerso en backend (recomendado).
- KPIs y grid interactivo: OK; con stats derivadas (useMesaStats).
- Cobro transaccional: Expuesto vía acciones; confirmar UI/UX y recibo.
- Documentación técnica por archivo: ENTREGADA en esta sección.