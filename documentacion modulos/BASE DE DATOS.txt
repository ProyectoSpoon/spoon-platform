# Estructura Detallada - Sistema PostgreSQL Restaurante

**Fecha de Análisis:** 10 de Septiembre, 2025  
**Sistema:** Supabase PostgreSQL  
**Base de Datos:** Sistema integral de gestión de restaurantes

---

## 📋 TABLAS DEL ESQUEMA PUBLIC (44 tablas)

### **MÓDULO CORE**

#### **restaurants** - Información principal de restaurantes
```sql
CREATE TABLE restaurants (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    owner_id            UUID REFERENCES auth.users(id),      -- Propietario del restaurante
    name                VARCHAR(255),                         -- Nombre del restaurante
    description         TEXT,                                 -- Descripción general
    contact_phone       VARCHAR(20),                          -- Teléfono de contacto
    contact_email       VARCHAR(255),                         -- Email de contacto
    cuisine_type        VARCHAR(50),                          -- Tipo de cocina (legacy)
    address             TEXT,                                 -- Dirección completa
    city                VARCHAR(100),                         -- Ciudad (legacy)
    state               VARCHAR(100),                         -- Estado/Departamento (legacy)
    country             VARCHAR(50) DEFAULT 'Colombia',       -- País
    latitude            NUMERIC(10,8),                        -- Coordenada geográfica
    longitude           NUMERIC(11,8),                        -- Coordenada geográfica
    business_hours      JSONB DEFAULT '{}'::jsonb,            -- Horarios de funcionamiento
    logo_url            TEXT,                                 -- URL del logo
    cover_image_url     TEXT,                                 -- URL imagen de portada
    setup_completed     BOOLEAN DEFAULT false,                -- Setup inicial completado
    setup_step          INTEGER DEFAULT 1,                    -- Paso actual del setup (1-4)
    status              VARCHAR(20) DEFAULT 'configuring',    -- Estado: configuring, active, inactive
    created_at          TIMESTAMP DEFAULT now(),
    updated_at          TIMESTAMP DEFAULT now(),
    cuisine_type_id     UUID REFERENCES cuisine_types(id),    -- Tipo de cocina (normalizado)
    country_id          UUID REFERENCES countries(id),        -- País (normalizado)
    department_id       UUID REFERENCES departments(id),      -- Departamento (normalizado)
    city_id             UUID REFERENCES cities(id)            -- Ciudad (normalizado)
);

-- Constraints
ALTER TABLE restaurants ADD CONSTRAINT restaurants_setup_step_check 
    CHECK (setup_step BETWEEN 1 AND 4);
```

#### **users** - Perfiles de usuarios sincronizados con auth
```sql
CREATE TABLE users (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    first_name      VARCHAR(100) NOT NULL,                    -- Primer nombre
    last_name       VARCHAR(100) NOT NULL,                    -- Apellido
    email           VARCHAR(255) NOT NULL,                    -- Email (sincronizado con auth.users)
    phone           VARCHAR(20) NOT NULL,                     -- Teléfono
    role            VARCHAR(20) DEFAULT 'restaurant_owner',   -- Rol principal del usuario
    restaurant_id   UUID REFERENCES restaurants(id),         -- Restaurante que posee
    created_at      TIMESTAMP DEFAULT now(),
    updated_at      TIMESTAMP DEFAULT now(),
    last_login      TIMESTAMP,                               -- Último inicio de sesión
    is_active       BOOLEAN DEFAULT true                     -- Usuario activo
);
```

#### **user_roles** - Gestión de roles por restaurante
```sql
CREATE TABLE user_roles (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id         UUID NOT NULL REFERENCES users(id),      -- Usuario
    role_id         UUID NOT NULL REFERENCES system_roles(id), -- Rol del sistema
    restaurant_id   UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    assigned_by     UUID NOT NULL REFERENCES users(id),      -- Quien asignó el rol
    assigned_at     TIMESTAMP DEFAULT now(),                 -- Fecha de asignación
    is_active       BOOLEAN DEFAULT true,                    -- Rol activo
    notes           TEXT,                                    -- Notas adicionales
    created_at      TIMESTAMP DEFAULT now(),
    updated_at      TIMESTAMP DEFAULT now()
);
```

#### **permissions** - Catálogo de permisos del sistema
```sql
CREATE TABLE permissions (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name            TEXT NOT NULL,                           -- Nombre del permiso (formato: modulo.accion)
    module          TEXT NOT NULL,                           -- Módulo al que pertenece
    description     TEXT,                                    -- Descripción del permiso
    is_critical     BOOLEAN DEFAULT false,                   -- Permiso crítico del sistema
    created_at      TIMESTAMP DEFAULT now(),
    updated_at      TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE permissions ADD CONSTRAINT permissions_name_format_check 
    CHECK (name ~ '^[a-z_]+\.[a-z_]+$');
```

---

### **MÓDULO MENÚS Y PRODUCTOS**

#### **universal_products** - Catálogo universal de productos
```sql
CREATE TABLE universal_products (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name                    VARCHAR(255) NOT NULL,           -- Nombre del producto
    description             TEXT,                            -- Descripción detallada
    category_id             UUID NOT NULL REFERENCES universal_categories(id), -- Categoría
    search_tags             TEXT[] DEFAULT '{}'::text[],     -- Tags de búsqueda
    regional_names          TEXT[] DEFAULT '{}'::text[],     -- Nombres regionales
    preparation_method      VARCHAR(100),                    -- Método de preparación
    food_type               VARCHAR(50),                     -- Tipo de comida
    estimated_calories      INTEGER,                         -- Calorías estimadas
    is_vegetarian           BOOLEAN DEFAULT false,           -- Es vegetariano
    is_vegan                BOOLEAN DEFAULT false,           -- Es vegano
    suggested_price_min     INTEGER,                         -- Precio mínimo sugerido (centavos)
    suggested_price_max     INTEGER,                         -- Precio máximo sugerido (centavos)
    popularity_score        INTEGER DEFAULT 0,               -- Score de popularidad
    common_regions          TEXT[] DEFAULT '{}'::text[],     -- Regiones comunes
    is_verified             BOOLEAN DEFAULT false,           -- Producto verificado
    verification_notes      TEXT,                            -- Notas de verificación
    image_url               TEXT,                            -- URL de imagen
    image_alt               TEXT,                            -- Texto alternativo
    created_by              UUID REFERENCES users(id),       -- Creado por
    created_at              TIMESTAMP DEFAULT now(),
    updated_at              TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE universal_products ADD CONSTRAINT universal_products_prices_check 
    CHECK (suggested_price_min IS NULL OR suggested_price_max IS NULL OR suggested_price_min <= suggested_price_max);
ALTER TABLE universal_products ADD CONSTRAINT universal_products_image_alt_required_check 
    CHECK (image_url IS NULL OR image_alt IS NOT NULL);
```

#### **universal_categories** - Categorías de productos
```sql
CREATE TABLE universal_categories (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name            VARCHAR(100) NOT NULL,                   -- Nombre de la categoría
    slug            VARCHAR(100) NOT NULL UNIQUE,            -- Slug URL-friendly
    description     TEXT,                                    -- Descripción
    icon            VARCHAR(50),                             -- Icono representativo
    color           VARCHAR(7),                              -- Color en hexadecimal
    display_order   INTEGER NOT NULL,                        -- Orden de visualización
    is_active       BOOLEAN DEFAULT true,                    -- Categoría activa
    created_at      TIMESTAMP DEFAULT now(),
    updated_at      TIMESTAMP DEFAULT now()
);
```

#### **daily_menus** - Menús diarios por restaurante
```sql
CREATE TABLE daily_menus (
    id                              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id                   UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    menu_date                       DATE NOT NULL DEFAULT CURRENT_DATE,       -- Fecha del menú
    menu_price                      INTEGER NOT NULL,                         -- Precio del menú (centavos)
    status                          VARCHAR(20) DEFAULT 'active',             -- Estado: active, expired, inactive
    total_combinations_generated    INTEGER DEFAULT 0,                        -- Combinaciones generadas
    total_products_selected         INTEGER DEFAULT 0,                        -- Productos seleccionados
    categories_configured           INTEGER DEFAULT 0,                        -- Categorías configuradas
    created_at                      TIMESTAMP DEFAULT now(),
    updated_at                      TIMESTAMP DEFAULT now(),
    expires_at                      TIMESTAMP DEFAULT 
        ((CURRENT_DATE + '1 day'::interval) + ('22:00:00'::time)::interval)  -- Expira a las 22:00 del día siguiente
);

-- Constraints
ALTER TABLE daily_menus ADD CONSTRAINT daily_menus_menu_price_check 
    CHECK (menu_price > 0);
ALTER TABLE daily_menus ADD CONSTRAINT daily_menus_expires_check 
    CHECK (expires_at > created_at);
```

#### **daily_menu_selections** - Productos seleccionados para menú diario
```sql
CREATE TABLE daily_menu_selections (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    daily_menu_id       UUID NOT NULL REFERENCES daily_menus(id) ON DELETE CASCADE,
    universal_product_id UUID NOT NULL REFERENCES universal_products(id),
    category_id         UUID NOT NULL REFERENCES universal_categories(id),
    category_name       VARCHAR(100) NOT NULL,              -- Nombre de categoría (desnormalizado)
    product_name        VARCHAR(255) NOT NULL,              -- Nombre del producto (desnormalizado)
    selected_at         TIMESTAMP DEFAULT now(),
    selection_order     INTEGER DEFAULT 0                   -- Orden de selección
);
```

#### **generated_combinations** - Combinaciones generadas automáticamente
```sql
CREATE TABLE generated_combinations (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    daily_menu_id           UUID NOT NULL REFERENCES daily_menus(id) ON DELETE CASCADE,
    combination_name        VARCHAR(300) NOT NULL,          -- Nombre descriptivo de la combinación
    combination_description TEXT,                           -- Descripción detallada
    combination_price       INTEGER NOT NULL,               -- Precio de la combinación (centavos)
    entrada_product_id      UUID REFERENCES universal_products(id),        -- Entrada (opcional)
    principio_product_id    UUID NOT NULL REFERENCES universal_products(id), -- Plato principal
    proteina_product_id     UUID NOT NULL REFERENCES universal_products(id), -- Proteína
    acompanamiento_products UUID[] DEFAULT '{}'::uuid[],    -- Array de acompañamientos
    bebida_product_id       UUID REFERENCES universal_products(id),        -- Bebida (opcional)
    is_available            BOOLEAN DEFAULT true,           -- Disponible para venta
    is_favorite             BOOLEAN DEFAULT false,          -- Marcado como favorito
    is_special              BOOLEAN DEFAULT false,          -- Combinación especial
    generated_at            TIMESTAMP DEFAULT now(),
    updated_at              TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE generated_combinations ADD CONSTRAINT generated_combinations_price_check 
    CHECK (combination_price > 0);
```

#### **protein_quantities** - Cantidades planificadas de proteínas
```sql
CREATE TABLE protein_quantities (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    daily_menu_id           UUID NOT NULL REFERENCES daily_menus(id) ON DELETE CASCADE,
    protein_product_id      UUID NOT NULL REFERENCES universal_products(id),
    planned_quantity        INTEGER NOT NULL DEFAULT 10,    -- Cantidad planificada
    unit_type               VARCHAR(20) DEFAULT 'units',    -- Tipo de unidad: units, kg, portions
    usage_frequency_score   INTEGER DEFAULT 1,              -- Score de frecuencia de uso
    created_at              TIMESTAMP DEFAULT now(),
    updated_at              TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE protein_quantities ADD CONSTRAINT protein_quantities_planned_check 
    CHECK (planned_quantity > 0);
```

---

### **MÓDULO ESPECIALES**

#### **special_dishes** - Platos especiales por restaurante
```sql
CREATE TABLE special_dishes (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id           UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    dish_name               VARCHAR(255) NOT NULL,          -- Nombre del plato especial
    dish_description        TEXT,                           -- Descripción del plato
    dish_price              INTEGER NOT NULL,               -- Precio base (centavos)
    is_active               BOOLEAN DEFAULT false,          -- Activo para venta
    is_template             BOOLEAN DEFAULT true,           -- Es plantilla para generar combinaciones
    status                  VARCHAR(20) DEFAULT 'draft',    -- Estado: draft, configured, active
    total_products_selected INTEGER DEFAULT 0,              -- Productos seleccionados
    categories_configured   INTEGER DEFAULT 0,              -- Categorías configuradas
    setup_completed         BOOLEAN DEFAULT false,          -- Setup completado
    created_at              TIMESTAMP DEFAULT now(),
    updated_at              TIMESTAMP DEFAULT now(),
    image_url               TEXT,                           -- URL de imagen del plato
    image_alt               TEXT                            -- Texto alternativo para accesibilidad
);

-- Constraints
ALTER TABLE special_dishes ADD CONSTRAINT special_dishes_price_check 
    CHECK (dish_price > 0);
ALTER TABLE special_dishes ADD CONSTRAINT special_dishes_image_alt_check 
    CHECK (image_url IS NULL OR image_alt IS NOT NULL);
```

#### **special_dish_selections** - Productos de platos especiales
```sql
CREATE TABLE special_dish_selections (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    special_dish_id     UUID NOT NULL REFERENCES special_dishes(id) ON DELETE CASCADE,
    universal_product_id UUID NOT NULL REFERENCES universal_products(id),
    category_id         UUID NOT NULL REFERENCES universal_categories(id),
    category_name       VARCHAR(100) NOT NULL,              -- Desnormalizado
    product_name        VARCHAR(255) NOT NULL,              -- Desnormalizado
    selection_order     INTEGER DEFAULT 0,                  -- Orden de selección
    is_required         BOOLEAN DEFAULT true,               -- Producto obligatorio
    selected_at         TIMESTAMP DEFAULT now()
);
```

#### **generated_special_combinations** - Combinaciones de especiales
```sql
CREATE TABLE generated_special_combinations (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    special_dish_id         UUID NOT NULL REFERENCES special_dishes(id) ON DELETE CASCADE,
    combination_name        VARCHAR(300) NOT NULL,          -- Nombre de la combinación
    combination_description TEXT,                           -- Descripción
    combination_price       INTEGER NOT NULL,               -- Precio (centavos)
    entrada_product_id      UUID REFERENCES universal_products(id),
    principio_product_id    UUID REFERENCES universal_products(id),
    proteina_product_id     UUID NOT NULL REFERENCES universal_products(id),
    acompanamiento_products UUID[],                         -- Array de acompañamientos
    bebida_product_id       UUID REFERENCES universal_products(id),
    is_available            BOOLEAN DEFAULT true,
    is_favorite             BOOLEAN DEFAULT false,
    is_featured             BOOLEAN DEFAULT false,          -- Destacado en menú
    available_today         BOOLEAN DEFAULT false,          -- Disponible hoy
    max_daily_quantity      INTEGER,                        -- Cantidad máxima diaria
    current_sold_quantity   INTEGER DEFAULT 0,              -- Cantidad vendida hoy
    generated_at            TIMESTAMP DEFAULT now(),
    updated_at              TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE generated_special_combinations ADD CONSTRAINT generated_special_combinations_price_check 
    CHECK (combination_price > 0);
ALTER TABLE generated_special_combinations ADD CONSTRAINT generated_special_combinations_quantity_check 
    CHECK (current_sold_quantity >= 0);
```

#### **daily_special_activations** - Activaciones diarias de especiales
```sql
CREATE TABLE daily_special_activations (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id           UUID NOT NULL REFERENCES restaurants(id),
    special_dish_id         UUID NOT NULL REFERENCES special_dishes(id),
    activation_date         DATE NOT NULL DEFAULT CURRENT_DATE,
    is_active               BOOLEAN DEFAULT true,
    daily_price_override    INTEGER,                        -- Precio especial del día
    daily_max_quantity      INTEGER,                        -- Cantidad máxima del día
    notes                   TEXT,                           -- Notas especiales
    activated_at            TIMESTAMP DEFAULT now(),
    deactivated_at          TIMESTAMP                       -- Fecha de desactivación
);
```

#### **special_protein_quantities** - Cantidades de proteínas para especiales
```sql
CREATE TABLE special_protein_quantities (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    special_dish_id         UUID NOT NULL REFERENCES special_dishes(id) ON DELETE CASCADE,
    protein_product_id      UUID NOT NULL REFERENCES universal_products(id),
    planned_quantity        INTEGER NOT NULL DEFAULT 0,     -- Cantidad planificada
    available_quantity      INTEGER NOT NULL DEFAULT 0,     -- Cantidad disponible
    reserved_quantity       INTEGER DEFAULT 0,              -- Cantidad reservada
    sold_quantity           INTEGER DEFAULT 0,              -- Cantidad vendida
    unit_type               VARCHAR(50) DEFAULT 'units',    -- Tipo de unidad
    price_override          INTEGER,                        -- Precio especial para esta proteína
    min_preparation_time    INTEGER,                        -- Tiempo mínimo de preparación (minutos)
    created_at              TIMESTAMP DEFAULT now(),
    updated_at              TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE special_protein_quantities ADD CONSTRAINT special_protein_quantities_quantities_check 
    CHECK (planned_quantity >= 0 AND available_quantity >= 0 AND reserved_quantity >= 0 AND sold_quantity >= 0);
```

---

### **MÓDULO OPERACIONES**

#### **restaurant_mesas** - Gestión de mesas
```sql
CREATE TABLE restaurant_mesas (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id       UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    numero              INTEGER NOT NULL,                   -- Número de mesa
    nombre              VARCHAR(100),                       -- Nombre descriptivo opcional
    capacidad_personas  INTEGER DEFAULT 4,                  -- Capacidad de personas
    estado              VARCHAR(20) DEFAULT 'libre',        -- Estado: libre, ocupada, reservada, inactiva
    notas               TEXT,                               -- Notas adicionales
    created_at          TIMESTAMP DEFAULT now(),
    updated_at          TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE restaurant_mesas ADD CONSTRAINT restaurant_mesas_capacidad_check 
    CHECK (capacidad_personas BETWEEN 1 AND 50);
ALTER TABLE restaurant_mesas ADD CONSTRAINT restaurant_mesas_estado_check 
    CHECK (estado IN ('libre', 'ocupada', 'reservada', 'inactiva'));
ALTER TABLE restaurant_mesas ADD CONSTRAINT restaurant_mesas_numero_restaurant_unique 
    UNIQUE (restaurant_id, numero);
```

#### **ordenes_mesa** - Órdenes dine-in
```sql
CREATE TABLE ordenes_mesa (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id           UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    numero_mesa             INTEGER NOT NULL,               -- Número de mesa
    monto_total             INTEGER NOT NULL,               -- Total en centavos COP
    estado                  VARCHAR(20) DEFAULT 'activa',   -- Estado: activa, pagada, completada
    nombre_mesero           VARCHAR(100),                   -- Nombre del mesero
    observaciones           TEXT,                           -- Observaciones especiales
    fecha_creacion          TIMESTAMP DEFAULT now(),
    fecha_actualizacion     TIMESTAMP DEFAULT now(),
    mesa_id                 UUID REFERENCES restaurant_mesas(id), -- Referencia a mesa específica
    pagada_at               TIMESTAMP                       -- Fecha y hora de pago
);

-- Constraints
ALTER TABLE ordenes_mesa ADD CONSTRAINT ordenes_mesa_monto_check 
    CHECK (monto_total > 0);
ALTER TABLE ordenes_mesa ADD CONSTRAINT ordenes_mesa_estado_check 
    CHECK (estado IN ('activa', 'pagada', 'completada'));
```

#### **items_orden_mesa** - Items de órdenes de mesa
```sql
CREATE TABLE items_orden_mesa (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    orden_mesa_id           UUID REFERENCES ordenes_mesa(id) ON DELETE CASCADE,
    combinacion_id          UUID REFERENCES generated_combinations(id),     -- Combinación regular
    combinacion_especial_id UUID REFERENCES generated_special_combinations(id), -- Combinación especial
    tipo_item               VARCHAR(20) NOT NULL,           -- Tipo: menu_dia, especial
    cantidad                INTEGER DEFAULT 1,              -- Cantidad del item
    precio_unitario         INTEGER NOT NULL,               -- Precio unitario (centavos)
    precio_total            INTEGER NOT NULL,               -- Precio total (cantidad × precio_unitario)
    observaciones_item      TEXT,                           -- Observaciones del item
    fecha_creacion          TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE items_orden_mesa ADD CONSTRAINT items_orden_mesa_cantidad_check 
    CHECK (cantidad > 0);
ALTER TABLE items_orden_mesa ADD CONSTRAINT items_orden_mesa_precio_check 
    CHECK (precio_unitario > 0 AND precio_total > 0);
ALTER TABLE items_orden_mesa ADD CONSTRAINT items_orden_mesa_tipo_check 
    CHECK (tipo_item IN ('menu_dia', 'especial'));
ALTER TABLE items_orden_mesa ADD CONSTRAINT items_orden_mesa_combinacion_check 
    CHECK ((combinacion_id IS NOT NULL AND combinacion_especial_id IS NULL) OR 
           (combinacion_id IS NULL AND combinacion_especial_id IS NOT NULL));
```

#### **delivery_orders** - Órdenes de delivery
```sql
CREATE TABLE delivery_orders (
    id                          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id               UUID NOT NULL REFERENCES restaurants(id),
    daily_menu_id               UUID NOT NULL REFERENCES daily_menus(id),
    customer_name               VARCHAR(100) NOT NULL,      -- Nombre del cliente
    customer_phone              VARCHAR(20) NOT NULL,       -- Teléfono del cliente
    delivery_address            TEXT NOT NULL,              -- Dirección de entrega
    order_items                 JSONB NOT NULL,             -- Items del pedido en JSON
    total_amount                INTEGER NOT NULL,           -- Monto total (centavos)
    delivery_fee                INTEGER DEFAULT 300000,     -- Tarifa de delivery (3000 COP)
    status                      VARCHAR(20) DEFAULT 'received', -- Estado del pedido
    assigned_delivery_person_id UUID REFERENCES delivery_personnel(id),
    estimated_delivery_minutes  INTEGER DEFAULT 30,         -- Tiempo estimado de entrega
    created_at                  TIMESTAMP DEFAULT now(),
    sent_at                     TIMESTAMP,                  -- Enviado para entrega
    delivered_at                TIMESTAMP,                  -- Entregado
    paid_at                     TIMESTAMP,                  -- Pagado
    special_notes               TEXT,                       -- Notas especiales
    pagada_at                   TIMESTAMP,                  -- Fecha de pago (legacy)
    cooking_started_at          TIMESTAMP                   -- Inicio de cocción
);

-- Constraints
ALTER TABLE delivery_orders ADD CONSTRAINT delivery_orders_total_check 
    CHECK (total_amount > 0);
ALTER TABLE delivery_orders ADD CONSTRAINT delivery_orders_delivery_fee_check 
    CHECK (delivery_fee >= 0);
ALTER TABLE delivery_orders ADD CONSTRAINT delivery_orders_status_check 
    CHECK (status IN ('received', 'cooking', 'ready', 'sent', 'delivered'));
```

#### **delivery_personnel** - Personal de delivery
```sql
CREATE TABLE delivery_personnel (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id   UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    name            VARCHAR(100) NOT NULL,              -- Nombre completo
    phone           VARCHAR(20) NOT NULL,               -- Teléfono
    is_active       BOOLEAN DEFAULT true,               -- Personal activo
    status          VARCHAR(20) DEFAULT 'available',    -- Estado: available, busy, offline
    created_at      TIMESTAMP DEFAULT now(),
    updated_at      TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE delivery_personnel ADD CONSTRAINT delivery_personnel_status_check 
    CHECK (status IN ('available', 'busy', 'offline'));
```

---

### **MÓDULO CAJA Y FINANZAS**

#### **caja_sesiones** - Sesiones de caja
```sql
CREATE TABLE caja_sesiones (
    id                      UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id           UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    cajero_id               UUID NOT NULL REFERENCES users(id),       -- Cajero responsable
    monto_inicial           INTEGER NOT NULL DEFAULT 0,    -- Monto inicial (centavos)
    estado                  VARCHAR(20) DEFAULT 'abierta', -- Estado: abierta, cerrada
    abierta_at              TIMESTAMP DEFAULT now(),       -- Fecha/hora apertura
    cerrada_at              TIMESTAMP,                     -- Fecha/hora cierre
    notas_apertura          TEXT,                          -- Notas de apertura
    notas_cierre            TEXT,                          -- Notas de cierre
    saldo_final_reportado   BIGINT                         -- Saldo final reportado por cajero
);

-- Constraints
ALTER TABLE caja_sesiones ADD CONSTRAINT caja_sesiones_monto_inicial_check 
    CHECK (monto_inicial >= 0);
ALTER TABLE caja_sesiones ADD CONSTRAINT caja_sesiones_estado_check 
    CHECK (estado IN ('abierta', 'cerrada'));
```

#### **transacciones_caja** - Transacciones de caja
```sql
CREATE TABLE transacciones_caja (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    caja_sesion_id      UUID NOT NULL REFERENCES caja_sesiones(id), -- Sesión de caja
    tipo_orden          VARCHAR(20),                        -- Tipo de orden: mesa, delivery
    metodo_pago         VARCHAR(20),                        -- Método: efectivo, tarjeta, transferencia
    monto_total         INTEGER NOT NULL,                   -- Monto total (centavos)
    monto_recibido      INTEGER,                           -- Monto recibido del cliente
    monto_cambio        INTEGER DEFAULT 0,                  -- Cambio entregado
    procesada_at        TIMESTAMP DEFAULT now(),           -- Fecha/hora de procesamiento
    cajero_id           UUID NOT NULL REFERENCES users(id), -- Cajero que procesó
    orden_mesa_id       UUID REFERENCES ordenes_mesa(id),   -- Orden de mesa (si aplica)
    delivery_order_id   UUID REFERENCES delivery_orders(id) -- Orden de delivery (si aplica)
);

-- Constraints
ALTER TABLE transacciones_caja ADD CONSTRAINT transacciones_caja_monto_check 
    CHECK (monto_total > 0);
ALTER TABLE transacciones_caja ADD CONSTRAINT transacciones_caja_cambio_check 
    CHECK (monto_cambio >= 0);
ALTER TABLE transacciones_caja ADD CONSTRAINT transacciones_caja_metodo_check 
    CHECK (metodo_pago IN ('efectivo', 'tarjeta', 'transferencia'));
ALTER TABLE transacciones_caja ADD CONSTRAINT transacciones_caja_orden_check 
    CHECK ((orden_mesa_id IS NOT NULL AND delivery_order_id IS NULL) OR 
           (orden_mesa_id IS NULL AND delivery_order_id IS NOT NULL));
```

#### **gastos_caja** - Gastos registrados
```sql
CREATE TABLE gastos_caja (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    caja_sesion_id  UUID REFERENCES caja_sesiones(id),      -- Sesión de caja (opcional)
    concepto        VARCHAR(255) NOT NULL,                  -- Concepto del gasto
    monto           INTEGER NOT NULL,                       -- Monto del gasto (centavos)
    categoria       VARCHAR(100),                           -- Categoría del gasto
    comprobante_url TEXT,                                   -- URL del comprobante
    registrado_por  UUID NOT NULL REFERENCES users(id),     -- Usuario que registró
    registrado_at   TIMESTAMP DEFAULT now(),               -- Fecha de registro
    notas           TEXT                                    -- Notas adicionales
);

-- Constraints
ALTER TABLE gastos_caja ADD CONSTRAINT gastos_caja_monto_check 
    CHECK (monto > 0);
```

#### **facturas** - Facturación
```sql
CREATE TABLE facturas (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id       UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    numero_factura      VARCHAR(20) NOT NULL,               -- Número de factura generado
    transaccion_id      UUID REFERENCES transacciones_caja(id),   -- Transacción asociada
    cliente_nombre      VARCHAR(255),                       -- Nombre del cliente
    cliente_documento   VARCHAR(50),                        -- Documento del cliente
    subtotal            INTEGER NOT NULL,                   -- Subtotal (centavos)
    impuestos           INTEGER DEFAULT 0,                  -- Impuestos (centavos)
    total               INTEGER NOT NULL,                   -- Total (centavos)
    metodo_pago         VARCHAR(20) NOT NULL,               -- Método de pago
    estado              VARCHAR(20) DEFAULT 'emitida',      -- Estado: emitida, anulada
    generada_at         TIMESTAMP DEFAULT now(),           -- Fecha de generación
    generada_por        UUID NOT NULL REFERENCES users(id), -- Usuario que generó
    datos_json          JSONB,                              -- Datos adicionales en JSON
    cliente_email       VARCHAR(255),                       -- Email del cliente
    cliente_telefono    VARCHAR(20),                        -- Teléfono del cliente
    motivo_anulacion    TEXT,                               -- Motivo de anulación
    anulada_at          TIMESTAMP,                          -- Fecha de anulación
    anulada_por         UUID REFERENCES users(id),          -- Usuario que anuló
    created_at          TIMESTAMP DEFAULT now(),
    updated_at          TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE facturas ADD CONSTRAINT facturas_total_check 
    CHECK (total > 0 AND subtotal > 0);
ALTER TABLE facturas ADD CONSTRAINT facturas_estado_check 
    CHECK (estado IN ('emitida', 'anulada'));
```

#### **numeracion_facturas** - Control de numeración
```sql
CREATE TABLE numeracion_facturas (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id   UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    prefijo         VARCHAR(10) DEFAULT 'FACT',             -- Prefijo de facturas
    numero_actual   INTEGER DEFAULT 1,                      -- Número actual
    ultimo_usado_at TIMESTAMP DEFAULT now(),               -- Último uso
    created_at      TIMESTAMP DEFAULT now(),
    updated_at      TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE numeracion_facturas ADD CONSTRAINT numeracion_facturas_numero_check 
    CHECK (numero_actual > 0);
```

---

### **MÓDULO SEGURIDAD Y AUDITORÍA**

#### **audit_log** - Log de auditoría general
```sql
CREATE TABLE audit_log (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    table_name  TEXT NOT NULL,                              -- Tabla afectada
    operation   TEXT NOT NULL,                              -- Operación: INSERT, UPDATE, DELETE
    old_data    JSONB,                                      -- Datos antiguos (UPDATE/DELETE)
    new_data    JSONB,                                      -- Datos nuevos (INSERT/UPDATE)
    user_id     UUID REFERENCES users(id),                  -- Usuario que realizó la acción
    timestamp   TIMESTAMP DEFAULT now()                     -- Timestamp de la acción
);
```

#### **audit_caja_sesiones** - Auditoría específica de caja
```sql
CREATE TABLE audit_caja_sesiones (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    operation_type  VARCHAR(10) NOT NULL,                   -- Tipo: INSERT, UPDATE, DELETE
    table_name      VARCHAR(50) NOT NULL DEFAULT 'caja_sesiones',
    record_id       UUID NOT NULL,                          -- ID del registro afectado
    old_values      JSONB,                                  -- Valores anteriores
    new_values      JSONB,                                  -- Valores nuevos
    changed_fields  TEXT[],                                 -- Campos que cambiaron
    user_id         UUID REFERENCES users(id),              -- Usuario
    session_info    JSONB,                                  -- Información de sesión
    ip_address      INET,                                   -- Dirección IP
    user_agent      TEXT,                                   -- User agent
    created_at      TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    restaurant_id   UUID REFERENCES restaurants(id)         -- Restaurante
);
```

#### **security_alerts** - Alertas de seguridad
```sql
CREATE TABLE security_alerts (
    id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id   UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    cajero_id       UUID REFERENCES users(id),              -- Cajero involucrado
    tipo_alerta     TEXT NOT NULL,                          -- Tipo de alerta
    severidad       TEXT DEFAULT 'media',                   -- Severidad: baja, media, alta, critica
    descripcion     TEXT NOT NULL,                          -- Descripción de la alerta
    datos_contexto  JSONB,                                  -- Datos de contexto
    revisada        BOOLEAN DEFAULT false,                  -- Alerta revisada
    revisada_por    UUID REFERENCES users(id),              -- Quien revisó
    revisada_at     TIMESTAMP,                              -- Fecha de revisión
    acciones_tomadas TEXT,                                  -- Acciones tomadas
    created_at      TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE security_alerts ADD CONSTRAINT security_alerts_severidad_check 
    CHECK (severidad IN ('baja', 'media', 'alta', 'critica'));
```

#### **security_policies** - Políticas de seguridad
```sql
CREATE TABLE security_policies (
    id                                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id                       UUID NOT NULL REFERENCES restaurants(id),
    limite_transaccion_normal           INTEGER DEFAULT 50000000,    -- Límite transacción normal (500,000 COP)
    limite_transaccion_efectivo         INTEGER DEFAULT 20000000,    -- Límite efectivo (200,000 COP)
    limite_autorizacion_supervisor      INTEGER DEFAULT 100000000,   -- Límite autorización supervisor (1,000,000 COP)
    limite_diario_cajero                INTEGER DEFAULT 500000000,   -- Límite diario cajero (5,000,000 COP)
    limite_transacciones_por_hora       INTEGER DEFAULT 50,          -- Límite transacciones por hora
    requiere_autorizacion_efectivo_alto BOOLEAN DEFAULT true,        -- Requiere autorización para efectivo alto
    limite_efectivo_sin_cambio          INTEGER DEFAULT 10000000,    -- Límite efectivo sin cambio (100,000 COP)
    alerta_transacciones_consecutivas   INTEGER DEFAULT 10,          -- Alerta por transacciones consecutivas
    alerta_monto_inusual_factor         NUMERIC DEFAULT 5.0,         -- Factor para montos inusuales
    requiere_justificacion_montos_altos BOOLEAN DEFAULT true,        -- Requiere justificación para montos altos
    requiere_supervisor_para_anulaciones BOOLEAN DEFAULT true,       -- Requiere supervisor para anulaciones
    created_at                          TIMESTAMP DEFAULT now(),
    updated_at                          TIMESTAMP DEFAULT now()
);
```

#### **authorization_requests** - Solicitudes de autorización
```sql
CREATE TABLE authorization_requests (
    id                  UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    restaurant_id       UUID NOT NULL REFERENCES restaurants(id), -- Restaurante
    cajero_id           UUID NOT NULL REFERENCES users(id),       -- Cajero solicitante
    supervisor_id       UUID REFERENCES users(id),                -- Supervisor autorizador
    tipo_autorizacion   TEXT NOT NULL,                           -- Tipo de autorización
    monto_solicitado    INTEGER,                                 -- Monto solicitado (si aplica)
    orden_id            UUID REFERENCES ordenes_mesa(id),        -- Orden relacionada (si aplica)
    motivo              TEXT,                                    -- Motivo de la solicitud
    justificacion       TEXT,                                    -- Justificación detallada
    estado              TEXT DEFAULT 'pendiente',               -- Estado: pendiente, aprobada, rechazada
    aprobada_at         TIMESTAMP,                               -- Fecha de aprobación
    rechazada_at        TIMESTAMP,                               -- Fecha de rechazo
    motivo_rechazo      TEXT,                                    -- Motivo del rechazo
    created_at          TIMESTAMP DEFAULT now()
);

-- Constraints
ALTER TABLE authorization_requests ADD CONSTRAINT authorization_requests_estado_check 
    CHECK (estado IN ('pendiente', 'aprobada', 'rechazada'));
```

---

### **TABLAS AUXILIARES**

#### **countries** - Países
```sql
CREATE TABLE countries (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name        VARCHAR(100) NOT NULL,                      -- Nombre del país
    code        VARCHAR(3) NOT NULL UNIQUE,                 -- Código de 3 letras
    iso_code    VARCHAR(2) NOT NULL UNIQUE,                 -- Código ISO de 2 letras
    phone_code  VARCHAR(10),                                -- Código telefónico
    currency    VARCHAR(10),                                -- Moneda
    is_active   BOOLEAN DEFAULT true,                       -- País activo
    created_at  TIMESTAMP DEFAULT now(),
    updated_at  TIMESTAMP DEFAULT now()
);
```

#### **departments** - Departamentos/Estados
```sql
CREATE TABLE departments (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name        VARCHAR(100) NOT NULL,                      -- Nombre del departamento
    code        VARCHAR(10) NOT NULL,                       -- Código del departamento
    country_id  UUID REFERENCES countries(id),              -- País
    is_active   BOOLEAN DEFAULT true,                       -- Departamento activo
    created_at  TIMESTAMP DEFAULT now(),
    updated_at  TIMESTAMP DEFAULT now()
);
```

#### **cities** - Ciudades
```sql
CREATE TABLE cities (
    id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name          VARCHAR(100) NOT NULL,                    -- Nombre de la ciudad
    department_id UUID REFERENCES departments(id),          -- Departamento
    latitude      NUMERIC(10,8),                           -- Latitud
    longitude     NUMERIC(11,8),                           -- Longitud
    population    INTEGER,                                 -- Población
    is_capital    BOOLEAN DEFAULT false,                   -- Es capital del departamento
    is_active     BOOLEAN DEFAULT true,                    -- Ciudad activa
    created_at    TIMESTAMP DEFAULT now(),
    updated_at    TIMESTAMP DEFAULT now()
);
```

#### **cuisine_types** - Tipos de cocina
```sql
CREATE TABLE cuisine_types (
    id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name          VARCHAR(100) NOT NULL,                   -- Nombre del tipo de cocina
    slug          VARCHAR(50) NOT NULL UNIQUE,             -- Slug URL-friendly
    description   TEXT,                                    -- Descripción
    icon          VARCHAR(20),                             -- Icono representativo
    is_active     BOOLEAN DEFAULT true,                    -- Tipo activo
    display_order INTEGER DEFAULT 0,                       -- Orden de visualización
    created_at    TIMESTAMP DEFAULT now(),
    updated_at    TIMESTAMP DEFAULT now()
);
```

---

## 👁️ VISTAS (5 total)

### **VISTAS PÚBLICAS (3)**

#### **restaurants_with_location** - Restaurantes con información geográfica completa
```sql
CREATE VIEW restaurants_with_location AS
SELECT 
    r.*,
    c.name as country_name,
    d.name as department_name,
    ct.name as city_name,
    cuis.name as cuisine_type_name,
    cuis.icon as cuisine_icon
FROM restaurants r
LEFT JOIN countries c ON c.id = r.country_id
LEFT JOIN departments d ON d.id = r.department_id
LEFT JOIN cities ct ON ct.id = r.city_id
LEFT JOIN cuisine_types cuis ON cuis.id = r.cuisine_type_id;
```

#### **v_active_menus_today** - Menús activos del día con estado
```sql
CREATE VIEW v_active_menus_today AS
SELECT 
    dm.*,
    r.name as restaurant_name,
    CASE 
        WHEN dm.expires_at < NOW() THEN 'expired'
        WHEN dm.status = 'active' THEN 'active'
        ELSE dm.status
    END as computed_status,
    (dm.expires_at - NOW()) as time_until_expiry
FROM daily_menus dm
JOIN restaurants r ON r.id = dm.restaurant_id
WHERE dm.menu_date = CURRENT_DATE;
```

#### **vw_mesas_inconsistentes** - Mesas ocupadas sin orden activa (control de calidad)
```sql
CREATE VIEW vw_mesas_inconsistentes AS
SELECT 
    m.id as mesa_id,
    m.restaurant_id,
    m.numero as numero_mesa,
    m.estado as estado_mesa,
    m.updated_at as mesa_updated_at,
    COUNT(o.id) as ordenes_activas_count
FROM restaurant_mesas m
LEFT JOIN ordenes_mesa o ON o.mesa_id = m.id AND o.estado = 'activa'
WHERE m.estado = 'ocupada'
GROUP BY m.id, m.restaurant_id, m.numero, m.estado, m.updated_at
HAVING COUNT(o.id) = 0;
```

### **VISTAS DEL SISTEMA (2)**

#### **pg_stat_statements** (extensions schema)
- Vista para estadísticas de consultas SQL ejecutadas
- Permite monitoreo de rendimiento de la base de datos

#### **decrypted_secrets** (vault schema)
- Vista para acceso controlado a secretos desencriptados
- Gestión segura de credenciales y configuraciones sensibles

---

## ⚙️ FUNCIONES PRINCIPALES (39 públicas)

### **FUNCIONES DE NEGOCIO**

#### **Gestión de Caja**
```sql
-- Apertura atómica de caja
CREATE OR REPLACE FUNCTION abrir_caja_atomico(
    p_restaurant_id UUID,
    p_cajero_id UUID,
    p_monto_inicial INTEGER,
    p_notas_apertura TEXT DEFAULT NULL
) RETURNS UUID;

-- Cierre atómico de caja
CREATE OR REPLACE FUNCTION cerrar_caja_atomico(
    p_caja_sesion_id UUID,
    p_saldo_final_reportado BIGINT,
    p_notas_cierre TEXT DEFAULT NULL
) RETURNS BOOLEAN;

-- Procesamiento atómico de pagos
CREATE OR REPLACE FUNCTION procesar_pago_atomico(
    p_caja_sesion_id UUID,
    p_orden_id UUID,
    p_tipo_orden TEXT,
    p_metodo_pago TEXT,
    p_monto_total INTEGER,
    p_monto_recibido INTEGER DEFAULT NULL
) RETURNS UUID;
```

#### **Seguridad y Validaciones**
```sql
-- Validación de seguridad en transacciones
CREATE OR REPLACE FUNCTION validar_seguridad_transaccion(
    p_restaurant_id UUID,
    p_cajero_id UUID,
    p_monto INTEGER,
    p_metodo_pago TEXT
) RETURNS JSONB;

-- Obtener permisos de usuario
CREATE OR REPLACE FUNCTION get_user_permissions(
    p_user_id UUID,
    p_restaurant_id UUID
) RETURNS TABLE(permission_name TEXT, module TEXT);
```

#### **Gestión de Especiales**
```sql
-- Activar/desactivar especiales del día
CREATE OR REPLACE FUNCTION toggle_special_today(
    p_restaurant_id UUID,
    p_special_dish_id UUID,
    p_activate BOOLEAN,
    p_daily_price_override INTEGER DEFAULT NULL,
    p_daily_max_quantity INTEGER DEFAULT NULL
) RETURNS BOOLEAN;

-- Obtener especiales disponibles hoy
CREATE OR REPLACE FUNCTION get_available_specials_today(
    p_restaurant_id UUID
) RETURNS TABLE(
    special_id UUID,
    dish_name TEXT,
    combination_name TEXT,
    price INTEGER,
    max_quantity INTEGER,
    sold_quantity INTEGER
);
```

#### **Utilidades**
```sql
-- Generación de números de factura
CREATE OR REPLACE FUNCTION generar_numero_factura(
    p_restaurant_id UUID
) RETURNS TEXT;

-- Búsqueda de productos universales
CREATE OR REPLACE FUNCTION search_universal_products(
    p_search_term TEXT,
    p_category_id UUID DEFAULT NULL,
    p_limit INTEGER DEFAULT 20
) RETURNS TABLE(
    id UUID,
    name TEXT,
    description TEXT,
    category_name TEXT,
    search_tags TEXT[]
);

-- Expiración automática de menús antiguos
CREATE OR REPLACE FUNCTION expire_old_menus() RETURNS INTEGER;
```

---

## 🔥 TRIGGERS (44 total)

### **TRIGGERS DE AUDITORÍA (6)**

#### **Auditoría de Caja**
```sql
-- Trigger para auditoría completa de caja_sesiones
CREATE TRIGGER trigger_audit_caja_sesiones
    AFTER INSERT OR UPDATE OR DELETE ON caja_sesiones
    FOR EACH ROW EXECUTE FUNCTION audit_caja_sesiones_changes();

-- Función de auditoría de caja
CREATE OR REPLACE FUNCTION audit_caja_sesiones_changes()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_caja_sesiones (
        operation_type, record_id, old_values, new_values, 
        changed_fields, user_id, session_info, ip_address, user_agent, restaurant_id
    ) VALUES (
        TG_OP,
        COALESCE(NEW.id, OLD.id),
        CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' THEN to_jsonb(NEW) 
             WHEN TG_OP = 'UPDATE' THEN to_jsonb(NEW) ELSE NULL END,
        CASE WHEN TG_OP = 'UPDATE' THEN get_changed_fields(to_jsonb(OLD), to_jsonb(NEW)) ELSE NULL END,
        auth.uid(),
        current_setting('request.headers', true)::jsonb,
        inet_client_addr(),
        current_setting('request.user_agent', true),
        COALESCE(NEW.restaurant_id, OLD.restaurant_id)
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

#### **Auditoría General**
```sql
-- Triggers de auditoría para tablas críticas
CREATE TRIGGER trg_audit_restaurants AFTER INSERT OR UPDATE OR DELETE ON restaurants
    FOR EACH ROW EXECUTE FUNCTION fn_audit_log();

CREATE TRIGGER trg_audit_users AFTER INSERT OR UPDATE OR DELETE ON users
    FOR EACH ROW EXECUTE FUNCTION fn_audit_log();

CREATE TRIGGER trg_audit_transacciones_caja AFTER INSERT OR UPDATE OR DELETE ON transacciones_caja
    FOR EACH ROW EXECUTE FUNCTION fn_audit_log();

-- Función general de auditoría
CREATE OR REPLACE FUNCTION fn_audit_log()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO audit_log (table_name, operation, old_data, new_data, user_id)
    VALUES (
        TG_TABLE_NAME,
        TG_OP,
        CASE WHEN TG_OP = 'DELETE' THEN to_jsonb(OLD) ELSE NULL END,
        CASE WHEN TG_OP = 'INSERT' THEN to_jsonb(NEW) 
             WHEN TG_OP = 'UPDATE' THEN to_jsonb(NEW) ELSE NULL END,
        auth.uid()
    );
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### **TRIGGERS DE ACTUALIZACIÓN AUTOMÁTICA (18)**

#### **Timestamps Automáticos**
```sql
-- Función para actualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers para todas las tablas con updated_at
CREATE TRIGGER update_restaurants_updated_at BEFORE UPDATE ON restaurants
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_daily_menus_updated_at BEFORE UPDATE ON daily_menus
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- (... y así para todas las tablas con updated_at)
```

#### **Actualizaciones de Estado**
```sql
-- Actualización automática de estado de mesas
CREATE TRIGGER trigger_actualizar_estado_mesa 
    AFTER INSERT OR UPDATE OR DELETE ON ordenes_mesa
    FOR EACH ROW EXECUTE FUNCTION actualizar_estado_mesa();

CREATE OR REPLACE FUNCTION actualizar_estado_mesa()
RETURNS TRIGGER AS $$
BEGIN
    -- Lógica para actualizar estado de mesa basado en órdenes activas
    IF TG_OP = 'INSERT' THEN
        UPDATE restaurant_mesas 
        SET estado = 'ocupada' 
        WHERE id = NEW.mesa_id;
    ELSIF TG_OP = 'DELETE' OR (TG_OP = 'UPDATE' AND NEW.estado != 'activa') THEN
        -- Verificar si quedan órdenes activas
        IF NOT EXISTS (
            SELECT 1 FROM ordenes_mesa 
            WHERE mesa_id = COALESCE(NEW.mesa_id, OLD.mesa_id) 
            AND estado = 'activa'
        ) THEN
            UPDATE restaurant_mesas 
            SET estado = 'libre' 
            WHERE id = COALESCE(NEW.mesa_id, OLD.mesa_id);
        END IF;
    END IF;
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;
```

### **TRIGGERS DE VALIDACIÓN Y CONTROL (8)**

#### **Validaciones de Caja**
```sql
-- Validación de estado de caja
CREATE TRIGGER trigger_validar_estado_caja 
    BEFORE INSERT OR UPDATE ON transacciones_caja
    FOR EACH ROW EXECUTE FUNCTION validar_estado_caja_sesion();

CREATE OR REPLACE FUNCTION validar_estado_caja_sesion()
RETURNS TRIGGER AS $$
DECLARE
    v_estado VARCHAR(20);
BEGIN
    SELECT estado INTO v_estado 
    FROM caja_sesiones 
    WHERE id = NEW.caja_sesion_id;
    
    IF v_estado != 'abierta' THEN
        RAISE EXCEPTION 'No se pueden procesar transacciones en una caja cerrada';
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### **Control de Consistencia**
```sql
-- Verificar consistencia entre mesa y orden
CREATE TRIGGER enforce_mesa_con_orden_activa 
    BEFORE UPDATE ON restaurant_mesas
    FOR EACH ROW EXECUTE FUNCTION validar_mesa_orden_consistencia();

CREATE OR REPLACE FUNCTION validar_mesa_orden_consistencia()
RETURNS TRIGGER AS $$
BEGIN
    -- Prevenir cambio a 'ocupada' sin orden activa
    IF NEW.estado = 'ocupada' AND OLD.estado != 'ocupada' THEN
        IF NOT EXISTS (
            SELECT 1 FROM ordenes_mesa 
            WHERE mesa_id = NEW.id AND estado = 'activa'
        ) THEN
            RAISE EXCEPTION 'No se puede marcar mesa como ocupada sin orden activa';
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### **TRIGGERS DE CÁLCULOS AUTOMÁTICOS (6)**

#### **Recálculo de Totales**
```sql
-- Recalcular total de orden cuando cambian items
CREATE TRIGGER trigger_recalcular_total_orden 
    AFTER INSERT OR UPDATE OR DELETE ON items_orden_mesa
    FOR EACH ROW EXECUTE FUNCTION recalcular_total_orden_mesa();

CREATE OR REPLACE FUNCTION recalcular_total_orden_mesa()
RETURNS TRIGGER AS $$
DECLARE
    v_orden_id UUID;
    v_nuevo_total INTEGER;
BEGIN
    v_orden_id := COALESCE(NEW.orden_mesa_id, OLD.orden_mesa_id);
    
    SELECT COALESCE(SUM(precio_total), 0) 
    INTO v_nuevo_total
    FROM items_orden_mesa 
    WHERE orden_mesa_id = v_orden_id;
    
    UPDATE ordenes_mesa 
    SET monto_total = v_nuevo_total,
        fecha_actualizacion = now()
    WHERE id = v_orden_id;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;
```

#### **Contadores Automáticos**
```sql
-- Actualizar contador de combinaciones
CREATE TRIGGER update_combinations_count 
    AFTER INSERT OR DELETE ON generated_combinations
    FOR EACH ROW EXECUTE FUNCTION update_daily_menu_stats();

CREATE OR REPLACE FUNCTION update_daily_menu_stats()
RETURNS TRIGGER AS $$
DECLARE
    v_menu_id UUID;
BEGIN
    v_menu_id := COALESCE(NEW.daily_menu_id, OLD.daily_menu_id);
    
    UPDATE daily_menus 
    SET total_combinations_generated = (
        SELECT COUNT(*) FROM generated_combinations 
        WHERE daily_menu_id = v_menu_id
    )
    WHERE id = v_menu_id;
    
    RETURN COALESCE(NEW, OLD);
END;
$$ LANGUAGE plpgsql;
```

### **TRIGGERS DE SINCRONIZACIÓN (6)**

#### **Sincronización de Disponibilidad**
```sql
-- Sincronizar disponibilidad de especiales
CREATE TRIGGER sync_special_availability 
    AFTER INSERT OR UPDATE ON daily_special_activations
    FOR EACH ROW EXECUTE FUNCTION sync_special_combinations_availability();

CREATE OR REPLACE FUNCTION sync_special_combinations_availability()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE generated_special_combinations 
    SET available_today = NEW.is_active
    WHERE special_dish_id = NEW.special_dish_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### **Sincronización de Propietarios**
```sql
-- Sincronizar propietario del restaurante
CREATE TRIGGER restaurant_owner_trigger 
    AFTER INSERT OR UPDATE ON restaurants
    FOR EACH ROW EXECUTE FUNCTION sync_restaurant_owner();

CREATE OR REPLACE FUNCTION sync_restaurant_owner()
RETURNS TRIGGER AS $$
BEGIN
    -- Actualizar restaurant_id en tabla users para el propietario
    UPDATE users 
    SET restaurant_id = NEW.id 
    WHERE id = NEW.owner_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

---

## 🔍 ÍNDICES (289 total)

### **ÍNDICES AUTOMÁTICOS (146)**
- **Primary Keys:** 67 índices únicos automáticos
- **Unique Constraints:** 79 índices únicos automáticos

### **ÍNDICES MANUALES DE FOREIGN KEYS (127)**
```sql
-- Ejemplos de índices de FK críticos
CREATE INDEX idx_restaurants_owner_id ON restaurants(owner_id);
CREATE INDEX idx_caja_sesiones_restaurant_id ON caja_sesiones(restaurant_id);
CREATE INDEX idx_caja_sesiones_cajero_id ON caja_sesiones(cajero_id);
CREATE INDEX idx_ordenes_mesa_restaurant_id ON ordenes_mesa(restaurant_id);
CREATE INDEX idx_ordenes_mesa_mesa_id ON ordenes_mesa(mesa_id);
CREATE INDEX idx_transacciones_caja_sesion_id ON transacciones_caja(caja_sesion_id);
CREATE INDEX idx_transacciones_caja_cajero_id ON transacciones_caja(cajero_id);
CREATE INDEX idx_daily_menus_restaurant_id ON daily_menus(restaurant_id);
CREATE INDEX idx_daily_menu_selections_menu_id ON daily_menu_selections(daily_menu_id);
CREATE INDEX idx_generated_combinations_menu_id ON generated_combinations(daily_menu_id);
```

### **ÍNDICES COMPUESTOS (89)**
```sql
-- Índices para consultas frecuentes
CREATE INDEX idx_daily_menus_restaurant_date ON daily_menus(restaurant_id, menu_date);
CREATE INDEX idx_ordenes_mesa_restaurant_estado ON ordenes_mesa(restaurant_id, estado);
CREATE INDEX idx_transacciones_caja_sesion_fecha ON transacciones_caja(caja_sesion_id, procesada_at);
CREATE INDEX idx_special_activations_restaurant_date ON daily_special_activations(restaurant_id, activation_date);
CREATE INDEX idx_audit_log_table_timestamp ON audit_log(table_name, timestamp);
CREATE INDEX idx_security_alerts_restaurant_revisada ON security_alerts(restaurant_id, revisada);
```

### **ÍNDICES PARCIALES (8)**
```sql
-- Índices para registros activos/específicos
CREATE INDEX idx_users_active ON users(restaurant_id) WHERE is_active = true;
CREATE INDEX idx_caja_sesiones_abiertas ON caja_sesiones(restaurant_id) WHERE estado = 'abierta';
CREATE INDEX idx_ordenes_mesa_activas ON ordenes_mesa(restaurant_id, numero_mesa) WHERE estado = 'activa';
CREATE INDEX idx_mesas_disponibles ON restaurant_mesas(restaurant_id) WHERE estado IN ('libre', 'reservada');
CREATE INDEX idx_daily_menus_active ON daily_menus(restaurant_id) WHERE status = 'active';
CREATE INDEX idx_special_dishes_active ON special_dishes(restaurant_id) WHERE is_active = true;
CREATE INDEX idx_security_alerts_pending ON security_alerts(restaurant_id, created_at) WHERE revisada = false;
CREATE INDEX idx_authorization_requests_pending ON authorization_requests(restaurant_id, created_at) WHERE estado = 'pendiente';
```

### **ÍNDICES GIN (3)**
```sql
-- Para búsquedas en arrays y JSONB
CREATE INDEX idx_universal_products_search_tags ON universal_products USING GIN(search_tags);
CREATE INDEX idx_universal_products_regional_names ON universal_products USING GIN(regional_names);
CREATE INDEX idx_restaurants_business_hours ON restaurants USING GIN(business_hours);
```

---

## 🔒 POLÍTICAS RLS (92 total)

### **AISLAMIENTO POR RESTAURANTE (78 políticas)**

#### **Patrón Estándar**
```sql
-- Política típica de aislamiento por restaurante
CREATE POLICY "Users can only access their restaurant's data" ON daily_menus
    FOR ALL USING (
        restaurant_id IN (
            SELECT users.restaurant_id 
            FROM users 
            WHERE users.id = auth.uid()
        )
    );

-- Aplicada a tablas principales:
-- restaurants, daily_menus, daily_menu_selections, generated_combinations,
-- special_dishes, special_dish_selections, generated_special_combinations,
-- restaurant_mesas, ordenes_mesa, items_orden_mesa, delivery_orders,
-- caja_sesiones, transacciones_caja, gastos_caja, facturas, etc.
```

### **CONTROL DE PROPIETARIO (12 políticas)**

#### **Solo Propietarios**
```sql
-- Política para propietarios de restaurantes
CREATE POLICY "Only restaurant owners can manage restaurants" ON restaurants
    FOR ALL USING (auth.uid() = owner_id);

-- Política para configuraciones críticas
CREATE POLICY "Only owners can manage security policies" ON security_policies
    FOR ALL USING (
        restaurant_id IN (
            SELECT r.id FROM restaurants r 
            WHERE r.owner_id = auth.uid()
        )
    );
```

### **ROLES Y PERMISOS (6 políticas)**

#### **Control por Roles**
```sql
-- Política basada en roles del usuario
CREATE POLICY "Admin users can access all data" ON audit_log
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM users 
            WHERE users.id = auth.uid() 
            AND users.role = 'admin'
        )
    );

-- Política para personal autorizado
CREATE POLICY "Cashiers can access transaction data" ON transacciones_caja
    FOR SELECT USING (
        EXISTS (
            SELECT 1 FROM user_roles ur
            JOIN system_roles sr ON sr.id = ur.role_id
            WHERE ur.user_id = auth.uid()
            AND sr.name IN ('cajero', 'supervisor', 'admin')
            AND ur.is_active = true
        )
    );
```

### **POLÍTICAS DE STORAGE**
```sql
-- Control de acceso a archivos
CREATE POLICY "Users can upload files to their restaurant folder" ON storage.objects
    FOR INSERT WITH CHECK (
        bucket_id = 'restaurant-assets' 
        AND (storage.foldername(name))[1] IN (
            SELECT r.id::text FROM restaurants r
            WHERE r.owner_id = auth.uid()
        )
    );
```

---

## ⚡ CONSTRAINTS (419 total)

### **CHECK CONSTRAINTS (273)**

#### **Validaciones Financieras**
```sql
-- Precios y montos positivos
ALTER TABLE daily_menus ADD CONSTRAINT daily_menus_menu_price_check 
    CHECK (menu_price > 0);

ALTER TABLE transacciones_caja ADD CONSTRAINT transacciones_caja_monto_check 
    CHECK (monto_total > 0);

ALTER TABLE transacciones_caja ADD CONSTRAINT transacciones_caja_cambio_check 
    CHECK (monto_cambio >= 0);

-- Rangos de precios válidos
ALTER TABLE universal_products ADD CONSTRAINT universal_products_prices_check 
    CHECK (suggested_price_min IS NULL OR suggested_price_max IS NULL OR 
           suggested_price_min <= suggested_price_max);
```

#### **Validaciones de Estado**
```sql
-- Estados válidos para mesas
ALTER TABLE restaurant_mesas ADD CONSTRAINT restaurant_mesas_estado_check 
    CHECK (estado IN ('libre', 'ocupada', 'reservada', 'inactiva'));

-- Estados válidos para órdenes
ALTER TABLE ordenes_mesa ADD CONSTRAINT ordenes_mesa_estado_check 
    CHECK (estado IN ('activa', 'pagada', 'completada'));

-- Estados válidos para delivery
ALTER TABLE delivery_orders ADD CONSTRAINT delivery_orders_status_check 
    CHECK (status IN ('received', 'cooking', 'ready', 'sent', 'delivered'));

-- Estados válidos para caja
ALTER TABLE caja_sesiones ADD CONSTRAINT caja_sesiones_estado_check 
    CHECK (estado IN ('abierta', 'cerrada'));
```

#### **Validaciones de Formato**
```sql
-- Formato de permisos
ALTER TABLE permissions ADD CONSTRAINT permissions_name_format_check 
    CHECK (name ~ '^[a-z_]+\.[a-z_]+$');

-- Formato de roles
ALTER TABLE system_roles ADD CONSTRAINT system_roles_name_format_check 
    CHECK (name ~ '^[a-z_]+$');

-- Capacidad de mesas
ALTER TABLE restaurant_mesas ADD CONSTRAINT restaurant_mesas_capacidad_check 
    CHECK (capacidad_personas BETWEEN 1 AND 50);

-- Pasos de setup
ALTER TABLE restaurants ADD CONSTRAINT restaurants_setup_step_check 
    CHECK (setup_step BETWEEN 1 AND 4);
```

#### **Validaciones de Consistencia**
```sql
-- Fechas de expiración futuras
ALTER TABLE daily_menus ADD CONSTRAINT daily_menus_expires_check 
    CHECK (expires_at > created_at);

-- Cantidades no negativas
ALTER TABLE protein_quantities ADD CONSTRAINT protein_quantities_planned_check 
    CHECK (planned_quantity > 0);

ALTER TABLE special_protein_quantities ADD CONSTRAINT special_protein_quantities_quantities_check 
    CHECK (planned_quantity >= 0 AND available_quantity >= 0 AND 
           reserved_quantity >= 0 AND sold_quantity >= 0);

-- Imágenes con texto alternativo obligatorio
ALTER TABLE universal_products ADD CONSTRAINT universal_products_image_alt_required_check 
    CHECK (image_url IS NULL OR image_alt IS NOT NULL);

-- Consistencia en items de orden
ALTER TABLE items_orden_mesa ADD CONSTRAINT items_orden_mesa_combinacion_check 
    CHECK ((combinacion_id IS NOT NULL AND combinacion_especial_id IS NULL) OR 
           (combinacion_id IS NULL AND combinacion_especial_id IS NOT NULL));
```

### **UNIQUE CONSTRAINTS (79)**
```sql
-- Ejemplos de constraints únicos importantes
ALTER TABLE restaurants ADD CONSTRAINT restaurants_owner_unique 
    UNIQUE (owner_id);

ALTER TABLE restaurant_mesas ADD CONSTRAINT restaurant_mesas_numero_restaurant_unique 
    UNIQUE (restaurant_id, numero);

ALTER TABLE numeracion_facturas ADD CONSTRAINT numeracion_facturas_restaurant_unique 
    UNIQUE (restaurant_id);

ALTER TABLE universal_categories ADD CONSTRAINT universal_categories_slug_unique 
    UNIQUE (slug);

ALTER TABLE cuisine_types ADD CONSTRAINT cuisine_types_slug_unique 
    UNIQUE (slug);
```

### **PRIMARY KEY CONSTRAINTS (67)**
- Todas las tablas tienen un ID UUID como clave primaria
- Generación automática con `gen_random_uuid()`
- Índices únicos automáticos para todas las PKs

---

## 🧩 EXTENSIONES ACTIVAS (7)

### **EXTENSIONES CORE**
```sql
-- Lenguaje procedural (habilitado por defecto)
CREATE EXTENSION IF NOT EXISTS plpgsql;

-- Funciones criptográficas para seguridad
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Generación de UUIDs
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
```

### **EXTENSIONES SUPABASE**
```sql
-- Programador de tareas automáticas
CREATE EXTENSION IF NOT EXISTS pg_cron;

-- API GraphQL automática
CREATE EXTENSION IF NOT EXISTS pg_graphql;

-- Gestión segura de secretos
CREATE EXTENSION IF NOT EXISTS supabase_vault;

-- Estadísticas de consultas para optimización
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
```

---

## 📊 ESTADÍSTICAS DEL SISTEMA

### **DISTRIBUCIÓN DE DATOS**
- **Tablas de Negocio:** 44 (55%)
- **Tablas de Sistema:** 36 (45%)
- **Índices Efectivos:** 289 (100% FK indexadas)
- **Cobertura RLS:** 96 políticas (100% tablas públicas)
- **Validaciones:** 419 constraints activos

### **OPTIMIZACIONES IMPLEMENTADAS**
- ✅ **Indexación completa** de todas las Foreign Keys
- ✅ **Políticas RLS** en 100% de tablas públicas  
- ✅ **Auditoría automática** con triggers especializados
- ✅ **Validaciones robustas** con 273 CHECK constraints
- ✅ **Cálculos automáticos** via triggers actualizadores
- ✅ **Particionado temporal** en realtime.messages

### **PUNTOS DE MONITOREO**
- Consultar `pg_stat_statements` mensualmente para consultas lentas
- Revisar `audit_log` para patrones de uso anómalos  
- Monitorear `security_alerts` para problemas de seguridad
- Evaluar `caja_sesiones` para inconsistencias financieras
- Analizar índices con `pg_stat_user_indexes` trimestralmente

---

# Inventario Técnico PostgreSQL - Base de Datos de Restaurante

**Fecha de Análisis:** 10 de Septiembre, 2025  
**Sistema:** Supabase PostgreSQL  
**Propósito:** Sistema integral de gestión de restaurantes con POS, delivery y administración

---

## 📊 Métricas Resumidas

### **Resumen Ejecutivo**
- **Total Tablas:** 80 (44 públicas + 36 sistema)
- **Total Vistas:** 5 (3 públicas + 2 sistema)
- **Total Funciones:** 136 (39 públicas + 97 sistema)
- **Total Triggers:** 44 (37 públicas + 7 sistema)
- **Total Índices:** 289 (bien distribuidos)
- **Total Foreign Keys:** 127 (100% indexadas ✅)
- **Total Políticas RLS:** 96 (excelente seguridad ✅)
- **Total Constraints:** 419 (validación robusta ✅)
- **Extensiones Activas:** 7
- **Esquemas:** 11

### **Estado de Optimización**
- ✅ **Excelente:** Todas las FK están indexadas
- ✅ **Excelente:** RLS implementado en todas las tablas públicas
- ✅ **Excelente:** Triggers de auditoría y actualización automática
- ✅ **Excelente:** Constraints de validación de negocio
- ✅ **Bueno:** Índices bien distribuidos (289 total)
- ⚠️ **Atención:** Algunas tablas con muchas columnas (35 en `users`)

---

Nueva sección "🚨 LECCIONES APRENDIDAS":

Error 42P17 de recursión RLS resuelto
Simplificación de políticas de users
Recomendación: RLS simple, lógica compleja en aplicación




## 1. 📋 TABLAS (80 total)

### **Esquema Public (44 tablas)**

#### **Módulo Core**
| Tabla | Columnas | FKs | Propósito |
|-------|----------|-----|-----------|
| `restaurants` | 25 | 5 | **Información principal de restaurantes** |
| `users` | 11 | 1 | Perfiles de usuarios sincronizados con auth |
| `user_roles` | 10 | 4 | Gestión de roles por restaurante |
| `permissions` | 7 | 0 | Catálogo de permisos del sistema |

#### **Módulo Menús y Productos**
| Tabla | Columnas | FKs | Propósito |
|-------|----------|-----|-----------|
| `daily_menus` | 11 | 1 | Menús diarios por restaurante |
| `daily_menu_selections` | 8 | 3 | Productos seleccionados para menú |
| `generated_combinations` | 15 | 5 | Combinaciones generadas automáticamente |
| `universal_products` | 22 | 2 | Catálogo universal de productos |
| `universal_categories` | 10 | 0 | Categorías de productos |
| `protein_quantities` | 8 | 2 | Cantidades planificadas de proteínas |

#### **Módulo Especiales**
| Tabla | Columnas | FKs | Propósito |
|-------|----------|-----|-----------|
| `special_dishes` | 15 | 1 | Platos especiales por restaurante |
| `special_dish_selections` | 9 | 2 | Productos de platos especiales |
| `generated_special_combinations` | 18 | 5 | Combinaciones de especiales |
| `daily_special_activations` | 10 | 2 | Activaciones diarias de especiales |
| `special_protein_quantities` | 12 | 2 | Cantidades de proteínas para especiales |

#### **Módulo Operaciones**
| Tabla | Columnas | FKs | Propósito |
|-------|----------|-----|-----------|
| `restaurant_mesas` | 9 | 1 | Gestión de mesas |
| `ordenes_mesa` | 11 | 2 | **Órdenes dine-in** |
| `items_orden_mesa` | 10 | 3 | Items de órdenes de mesa |
| `delivery_orders` | 19 | 3 | Órdenes de delivery |
| `delivery_personnel` | 8 | 1 | Personal de delivery |

#### **Módulo Caja y Finanzas**
| Tabla | Columnas | FKs | Propósito |
|-------|----------|-----|-----------|
| `caja_sesiones` | 10 | 2 | **Sesiones de caja** |
| `transacciones_caja` | 11 | 4 | Transacciones de caja |
| `gastos_caja` | 9 | 2 | Gastos registrados |
| `facturas` | 21 | 4 | Facturación |
| `numeracion_facturas` | 7 | 1 | Control de numeración |

#### **Módulo Seguridad y Auditoría**
| Tabla | Columnas | FKs | Propósito |
|-------|----------|-----|-----------|
| `audit_log` | 7 | 1 | Log de auditoría general |
| `audit_caja_sesiones` | 13 | 2 | Auditoría específica de caja |
| `security_alerts` | 12 | 3 | Alertas de seguridad |
| `security_policies` | 15 | 1 | Políticas de seguridad |
| `authorization_requests` | 14 | 3 | Solicitudes de autorización |

### **Esquemas del Sistema**

#### **Auth (17 tablas)**
- `users` (35 columnas) - Usuarios de autenticación
- `sessions`, `refresh_tokens`, `identities` - Gestión de sesiones
- `mfa_factors`, `mfa_challenges` - Autenticación multifactor
- `flow_state`, `one_time_tokens` - Estados de flujo PKCE

#### **Realtime (9 tablas)**
- `messages` + 7 particiones diarias (2025-09-07 a 2025-09-13)
- `subscription` - Suscripciones en tiempo real

#### **Storage (7 tablas)**
- `buckets`, `objects`, `prefixes` - Almacenamiento de archivos
- `s3_multipart_uploads*` - Uploads multiparte

---

## 2. 👁️ VISTAS (5 total)

### **Public (3 vistas)**
| Vista | Propósito |
|-------|-----------|
| `restaurants_with_location` | Restaurantes con información geográfica completa |
| `v_active_menus_today` | Menús activos del día con estado |
| `vw_mesas_inconsistentes` | Mesas ocupadas sin orden activa (control de calidad) |

### **Sistema (2 vistas)**
| Vista | Esquema | Propósito |
|-------|---------|-----------|
| `pg_stat_statements` | extensions | Estadísticas de consultas |
| `decrypted_secrets` | vault | Secretos desencriptados |

---

## 3. ⚙️ FUNCIONES (136 total)

### **Public (39 funciones)**

#### **Funciones de Negocio**
- `abrir_caja_atomico()` - Apertura atómica de caja
- `cerrar_caja_atomico()` - Cierre atómico de caja
- `procesar_pago_atomico()` - Procesamiento de pagos
- `validar_seguridad_transaccion()` - Validaciones de seguridad
- `get_user_permissions()` - Obtener permisos de usuario
- `toggle_special_today()` - Activar/desactivar especiales

#### **Funciones de Utilidad**
- `generar_numero_factura()` - Generación de números
- `search_universal_products()` - Búsqueda de productos
- `get_available_specials_today()` - Especiales disponibles
- `expire_old_menus()` - Expiración automática de menús

#### **Triggers (37 funciones)**
- `update_updated_at_column()` - Actualización automática de timestamps
- `actualizar_estado_mesa()` - Control de estados de mesa
- `audit_caja_sesiones_changes()` - Auditoría de cambios
- `fn_audit_log()` - Logging general de auditoría

### **Sistema (97 funciones)**

#### **Auth (4 funciones)**
- `jwt()`, `uid()`, `role()`, `email()` - Funciones de autenticación

#### **Extensions (55 funciones)**
- **Crypto:** `pgp_sym_encrypt()`, `gen_random_uuid()`, `crypt()`
- **UUID:** `uuid_generate_v4()`, `uuid_generate_v1()`
- **Stats:** `pg_stat_statements()`, `pg_stat_statements_reset()`

#### **Storage (23 funciones)**
- `search()`, `list_objects_with_delimiter()` - Gestión de archivos
- `can_insert_object()` - Validaciones de inserción

---

## 4. 🔥 TRIGGERS (44 total)

### **Por Tipo de Operación**

#### **Auditoría (6 triggers)**
- `trigger_audit_caja_sesiones` - Auditoría de caja
- `trg_audit_*` (4 triggers) - Auditoría general

#### **Actualización Automática (18 triggers)**
- `update_*_updated_at` - Timestamps automáticos
- `trigger_actualizar_*` - Actualizaciones de estado

#### **Validación y Control (8 triggers)**
- `trigger_validar_estado_caja` - Validación de estados
- `enforce_mesa_con_orden_activa` - Control de consistencia
- `validar_estado_caja_sesion` - Validaciones de caja

#### **Cálculos Automáticos (6 triggers)**
- `trigger_recalcular_total_orden` - Recálculo de totales
- `update_combinations_count` - Contadores automáticos

#### **Sincronización (6 triggers)**
- `sync_special_availability` - Sincronización de disponibilidad
- `restaurant_owner_trigger` - Sincronización de propietarios

---

## 5. 🔍 ÍNDICES (289 total)

### **Distribución por Esquema**
- **Public:** 181 índices (62.6%)
- **Auth:** 61 índices (21.1%)
- **Storage:** 31 índices (10.7%)
- **Realtime:** 14 índices (4.8%)
- **Otros:** 2 índices (0.7%)

### **Por Tipo**
- **B-tree:** 285 índices (98.6%)
- **GIN:** 3 índices (1.0%) - Para arrays y JSONB
- **Hash:** 1 índice (0.3%)

### **Estado de Optimización**
- ✅ **Primary Keys:** 67 (todas indexadas automáticamente)
- ✅ **Unique Constraints:** 79 (todas indexadas automáticamente)
- ✅ **Foreign Keys:** 127 (100% indexadas manualmente)
- ✅ **Índices Compuestos:** 89 para consultas complejas
- ✅ **Índices Parciales:** 8 para optimización específica

---

## 6. 🔗 FOREIGN KEYS (127 total)

### **Estado de Indexación: 100% ✅**

#### **Relaciones Principales**
| Tabla Origen | Columna | Tabla Destino | Estado Índice |
|--------------|---------|---------------|---------------|
| `restaurants` | `owner_id` | `users` | ✅ INDEXED |
| `caja_sesiones` | `restaurant_id` | `restaurants` | ✅ INDEXED |
| `ordenes_mesa` | `restaurant_id` | `restaurants` | ✅ INDEXED |
| `daily_menus` | `restaurant_id` | `restaurants` | ✅ INDEXED |
| `transacciones_caja` | `caja_sesion_id` | `caja_sesiones` | ✅ INDEXED |

#### **Reglas de Integridad**
- **CASCADE:** 89 FKs (70%) - Eliminación en cascada
- **NO ACTION:** 28 FKs (22%) - Prevención de eliminación
- **SET NULL:** 8 FKs (6%) - Nulificación automática
- **RESTRICT:** 2 FKs (2%) - Restricción estricta

---

## 7. 🔒 POLÍTICAS RLS (96 total)

### **Cobertura de Seguridad: 100% ✅**

#### **Por Esquema**
- **Public:** 93 políticas (96.9%)
- **Storage:** 1 política (1.0%)
- **Cron:** 2 políticas (2.1%)

#### **Por Tipo de Operación**
- **SELECT:** 35 políticas (36.5%)
- **ALL:** 34 políticas (35.4%)
- **INSERT:** 15 políticas (15.6%)
- **UPDATE:** 12 políticas (12.5%)

#### **Patrones de Seguridad**
- **Aislamiento por Restaurante:** 78 políticas
- **Control de Propietario:** 12 políticas
- **Roles y Permisos:** 6 políticas

### **Ejemplos Clave**
```sql
-- Aislamiento por restaurante
restaurant_id IN (SELECT users.restaurant_id FROM users WHERE users.id = auth.uid())

-- Control de propietario
auth.uid() = owner_id

-- Validación de roles
EXISTS (SELECT 1 FROM users WHERE users.id = auth.uid() AND users.role = 'admin')
```

---

## 8. ⚡ CONSTRAINTS (419 total)

### **Por Tipo**
- **CHECK:** 273 constraints (65.2%)
- **UNIQUE:** 79 constraints (18.9%)
- **PRIMARY KEY:** 67 constraints (16.0%)

### **Validaciones de Negocio Implementadas**

#### **Validaciones Financieras**
- Precios positivos: `menu_price > 0`
- Cantidades válidas: `cantidad > 0`
- Rangos de precios: `suggested_price_min <= suggested_price_max`

#### **Validaciones de Estado**
- Estados de mesa: `'libre', 'ocupada', 'reservada', 'inactiva'`
- Estados de orden: `'activa', 'pagada', 'completada'`
- Estados de delivery: `'received', 'cooking', 'ready', 'sent', 'delivered'`

#### **Validaciones de Formato**
- Permisos: `name ~ '^[a-z_]+\.[a-z_]+$'`
- Roles: `name ~ '^[a-z_]+$'`
- Capacidades: `capacidad_personas BETWEEN 1 AND 50`

#### **Validaciones de Consistencia**
- Fechas futuras: `expires_at > created_at`
- Rangos numéricos: `setup_step BETWEEN 1 AND 4`
- Imágenes con alt text obligatorio

---

## 9. 🧩 EXTENSIONES (7 total)

| Extensión | Versión | Esquema | Propósito |
|-----------|---------|---------|-----------|
| `plpgsql` | 1.0 | pg_catalog | **Lenguaje procedural** |
| `pg_cron` | 1.6 | pg_catalog | **Programador de tareas** |
| `pg_graphql` | 1.5.11 | graphql | **API GraphQL** |
| `pg_stat_statements` | 1.11 | extensions | **Estadísticas de consultas** |
| `pgcrypto` | 1.3 | extensions | **Funciones criptográficas** |
| `uuid-ossp` | 1.1 | extensions | **Generación de UUIDs** |
| `supabase_vault` | 0.3.1 | vault | **Gestión de secretos** |

---

## 10. 📁 ESQUEMAS (11 total)

| Esquema | Propietario | Tablas | Vistas | Funciones | Propósito |
|---------|-------------|--------|--------|-----------|-----------|
| `public` | pg_database_owner | 44 | 3 | 39 | **Lógica de negocio principal** |
| `auth` | supabase_admin | 17 | 0 | 4 | **Autenticación y autorización** |
| `storage` | supabase_admin | 7 | 0 | 23 | **Almacenamiento de archivos** |
| `realtime` | supabase_admin | 9 | 0 | 12 | **Comunicación en tiempo real** |
| `vault` | supabase_admin | 1 | 1 | 5 | **Gestión segura de secretos** |
| `extensions` | postgres | 0 | 2 | 55 | **Funciones de extensiones** |
| `graphql` | supabase_admin | 0 | 0 | 6 | **API GraphQL** |
| `cron` | supabase_admin | 2 | 0 | 7 | **Tareas programadas** |
| `pgbouncer` | pgbouncer | 0 | 0 | 1 | **Pool de conexiones** |
| `graphql_public` | supabase_admin | 0 | 0 | 1 | **GraphQL público** |
| `pg_catalog` | supabase_admin | 64 | 78 | 3319 | **Catálogo del sistema** |

---

## 📈 Análisis de Rendimiento

### **Fortalezas**
1. **Indexación Completa:** Todas las FK indexadas
2. **Seguridad Robusta:** RLS en 100% de tablas públicas
3. **Auditoría Completa:** Triggers y logs implementados
4. **Validación Exhaustiva:** 273 CHECK constraints
5. **Arquitectura Modular:** Separación clara por funcionalidad

### **Oportunidades de Mejora**
1. **Particionado:** Considerar para `audit_log` y `transacciones_caja`
2. **Archivado:** Implementar para datos históricos antiguos
3. **Índices Compuestos:** Revisar consultas frecuentes para optimizar
4. **Materialización:** Evaluar vistas materializadas para reportes

### **Monitoring Recomendado**
- Monitorear `pg_stat_statements` para consultas lentas
- Revisar tamaño de índices mensualmente
- Auditar políticas RLS trimestralmente
- Evaluar particionado cuando `audit_log` > 10M registros

---

## 🎯 Resumen Ejecutivo

Esta base de datos PostgreSQL presenta una **arquitectura sólida y bien optimizada** para un sistema de gestión de restaurantes. Con 92 políticas RLS, 127 FK indexadas y 419 constraints, demuestra un enfoque integral hacia la seguridad, integridad y rendimiento.

**Estado General: EXCELENTE ✅**

La implementación incluye módulos especializados para POS, delivery, gestión de inventarios, facturación y auditoría, con una base técnica que soporta escalabilidad y mantiene altos estándares de calidad de datos.